
523. Continuous Subarray Sum

  Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.

  A good subarray is a subarray where:
    - its length is at least two, and
    - the sum of the elements of the subarray is a multiple of k.
  Note that:
    - A subarray is a contiguous part of the array.
    - An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.

  #########################
  # Performant approach: Iterate over the Array once, calculate the current sum of the
  # elements we've seen so far, create a Hash with key-value pairs of the remainder
  # and the index of the current number. If the Hash already contains that remainder
  # and the distance between the current index and the index we last saw the remainder is > 1,
  # then return true because there's a subarray within the numbers we've iterated over
  # whose sum is divisible by k.
  #
  # @param {Integer[]} nums
  # @param {Integer} k
  # @return {Boolean}
  def check_subarray_sum(nums, k)
    # Create the remainders Hash with 0 => -1 key-value pair in case the number
    # at index 0 is divisible by k, since that would only be length 1.
    remainders = { 0 => -1 }
    sum = 0
    nums.each_with_index do |num, index|
      sum += num
      remainder = sum % k

      # If it's the first time we've seen this remainder, store it in the remainders Hash
      # { remainder: index_of_current_num }
      if remainders[remainder] == nil
        remainders[remainder] = index
      # If we've seen this remainder already, and the distance between the
      # current index and the index where we last saw that remainder is > 1
      # then return true.
      elsif index - remainders[remainder] > 1
        return true
      end
    end

    return false
  end

  #########################
  # Brute force: Try all subarrays of size at least two and return true if there's a
  # subarray divisible by k with no remainder or return false if we've reached the end.
  # But this solution is slow if the dataset is very large.
  #
  # @param {Integer[]} nums
  # @param {Integer} k
  # @return {Boolean}
  def check_subarray_sum(nums, k)
      # Iterate over each element num1 with its index
      nums.each_with_index do |num1, ind|
          # Return false if the current element is the last in the Array
          return false if ind == nums.length - 1
          # Set a sum value for the sum of the elements in the Array being evaluated
          sum = num1

          # Iterate over each element num2 after the current num1 element
          nums.drop(ind+1).each do |num2|
              # Set the sum of the current subarray
              sum += num2
              # Return true if the sum divided by k has no remainder
              # and is therefore a multiple of k.
              return true if sum % k == 0
          end
      end
  end


2404. Most Frequent Even Element

  Given an integer array nums, return the most frequent even element.

  If there is a tie, return the smallest one. If there is no such element, return -1.

  Examples:
    Input: nums = [0,1,2,2,4,4,1]           Output:  2
    Input: nums = [4,4,4,9,2,4]             Output:  4
    Input: nums = [29,47,21,41,13,37,25,7]  Output: -1

  #########################
  # @param {Integer[]} nums
  # @return {Integer}
  def most_frequent_even(nums)
    counts = {}
    most_frequent_even = -1

    nums.each do |num|
      # Fill the counts Hash with
      # keys of all the even numbers and
      # values of how frequently it appears.
      # e.g. Array nums = [0,1,2,2,4,4,1]
      # results in Hash counts = {0=>1, 2=>2, 4=>2}
      next unless num.even?
      counts[num].nil? ? counts[num] = 1 : counts[num] += 1

      # If this is the first even number we've seen OR
      # the even number is the most frequent OR
      # the even number is equally as frequent and smaller than the tracked even number,
      # then set the most frequent even number to this number.
      if most_frequent_even == -1 ||
        (counts[num] > counts[most_frequent_even]) ||
        (num < most_frequent_even && counts[num] == counts[most_frequent_even])
          most_frequent_even = num
      end
    end

    return most_frequent_even
  end


183. Customers Who Never Order

  Write an SQL query to report all customers who never order anything.

  Return the result table in any order.

  The query result format is in the following example.

  SQL Schema >

  Table: Customers

  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | id          | int     |
  | name        | varchar |
  +-------------+---------+
  id is the primary key column for this table.
  Each row of this table indicates the ID and name of a customer.


  Table: Orders

  +-------------+------+
  | Column Name | Type |
  +-------------+------+
  | id          | int  |
  | customerId  | int  |
  +-------------+------+
  id is the primary key column for this table.
  customerId is a foreign key of the ID from the Customers table.
  Each row of this table indicates the ID of an order and the ID of the customer who ordered it.

  #########################
  # LeetCode posted solution using a subquery
  # Runtime 998 ms
  #   SELECT name AS Customers FROM customers
  #   WHERE customers.id NOT IN (
  #       SELECT customerId FROM orders
  #   );


  # My solution using a join
  # Runtime 447 ms
  SELECT name AS Customers FROM customers
  LEFT JOIN orders ON orders.customerId=customers.id
  WHERE orders.customerId IS NULL;

  # My solution has a faster runtime because joins are
  # more optimized than subqueries (at least in MYSQL.)
